<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>For You | Galaxy Gift</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Cinzel', serif;
            cursor: grab;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center;
            z-index: 10;
        }

        #title {
            color: #fff; font-weight: 700; letter-spacing: 6px;
            text-shadow: 0 0 30px rgba(255, 200, 50, 0.8);
            opacity: 0; transition: opacity 2s ease; mix-blend-mode: screen; text-align: center;
            font-size: 3.5rem; 
        }
        
        #subtitle {
            margin-top: 10px; color: rgba(255, 255, 255, 0.8); 
            letter-spacing: 4px; opacity: 0; transition: opacity 2s ease 1s; 
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-size: 1.2rem;
        }

        /* 摄像头 */
        #video-container {
            position: absolute; z-index: 20;
            border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); background: rgba(0,0,0,0.5);
            bottom: 20px; right: 20px; width: 160px; height: 120px;
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; position: absolute; top:0; left:0;}
        #skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; font-size: 14px; letter-spacing: 2px; animation: pulse 1s infinite alternate;
            width: 100%; text-align: center;
        }
        @keyframes pulse { from { opacity: 0.3; } to { opacity: 1; text-shadow: 0 0 20px #ffd700; } }

        /* 上传按钮 */
        #upload-container {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            z-index: 30; pointer-events: auto; opacity: 0; transition: opacity 1s ease 3s;
        }
        #upload-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.8);
            color: #ffd700; padding: 12px 24px; border-radius: 30px;
            font-family: 'Cinzel', serif; font-size: 14px; cursor: pointer;
            backdrop-filter: blur(5px); transition: all 0.2s;
            display: flex; align-items: center; gap: 8px; box-shadow: 0 0 10px rgba(255,215,0,0.3);
            white-space: nowrap;
        }
        #upload-btn:active { transform: scale(0.95); background: rgba(255, 215, 0, 0.2); }
        #file-input { display: none; }
        
        #cursor-hint {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 50;
            display: none; box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            #title { font-size: 2.2rem; margin-bottom: 20px; }
            #subtitle { font-size: 0.9rem; }
            #video-container { width: 100px; height: 75px; top: 15px; right: 15px; bottom: auto; }
            #upload-container { bottom: 60px; }
            #upload-btn { padding: 10px 16px; font-size: 12px; }
            #ui-layer { justify-content: flex-start; padding-top: 120px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="video-container">
        <video id="input-video" playsinline muted></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>
    
    <div id="cursor-hint"></div>
    <div id="loading">INITIALIZING...</div>
    
    <div id="ui-layer">
        <div id="title">Merry Christmas</div>
        <div id="subtitle">The Galaxy of You</div>
    </div>

    <div id="upload-container">
        <button id="upload-btn">
            <span>✦</span> 上传照片 <span>✦</span>
        </button>
        <input type="file" id="file-input" multiple accept="image/*">
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleCount: 5000,
            particleColor: 0xffaa33, 
            treeHeight: 30, 
            treeRadius: 12,
            initialPhotos: [] 
        };

        // 默认占位图
        for (let i = 0; i < 20; i++) CONFIG.initialPhotos.push(`https://picsum.photos/id/${i + 50}/500/500`);

        const STATE = {
            mode: 'TREE',
            mix: 0,
            focusIndex: -1,
            hoverIndex: -1,
            pinchPos: new THREE.Vector2(),
            inputSource: 'NONE', 
            mousePos: new THREE.Vector2(),
            
            rotationY: 0,
            rotateVel: 0,
            isDragging: false,
            lastMouseX: 0,
            
            handPos: { x: 0, y: 0 },
            lastHandPos: { x: 0, y: 0 },
            isHandPresent: false
        };

        let scene, camera, renderer, composer;
        let mainGroup; 
        let particles, particleMaterial;
        let photoData = []; 
        let photoMeshes = [];
        let clock = new THREE.Clock();
        const cursorLight = new THREE.PointLight(0xffaa00, 0, 15);
        const raycaster = new THREE.Raycaster();

        // MediaPipe holders (for restart/resume)
        let MP_HANDS = null;
        let MP_CAMERA = null;
        let MP_LAST_TS = 0;

        init();
        initMediaPipe(); 
        initInput(); 
        initUpload();
        animate();

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            adjustCameraPosition();
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(cursorLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.25; bloomPass.strength = 1.2; bloomPass.radius = 0.35;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createSupernovaParticles();
            
            // 初始加载
            await loadAndBuildGallery(CONFIG.initialPhotos);

            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('title').style.opacity = 1;
                document.getElementById('subtitle').style.opacity = 1;
                document.getElementById('upload-container').style.opacity = 1;
            }, 1000);

            window.addEventListener('resize', onWindowResize);
        }

        function adjustCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1.0) camera.position.set(0, 2, 60 / aspect * 0.6); 
            else camera.position.set(0, 2, 40);
        }

        // --- 核心修复：上传逻辑 ---
        function initUpload() {
            const btn = document.getElementById('upload-btn');
            const input = document.getElementById('file-input');

            btn.addEventListener('click', () => { input.click(); });

            input.addEventListener('change', async (e) => {

const files = e.target.files;
if (!files || files.length === 0) return;

btn.innerText = "读取中...";

// 使用 1215.html 同款方案：FileReader(DataURL) -> Image -> THREE.Texture
const images = await Promise.all(Array.from(files).map(file => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}));

btn.innerText = "渲染中...";

// 2. 用 Image 创建纹理并构建画廊（更稳）
await loadAndBuildGalleryFromImages(images);

// 3. 上传完成，强制展开
STATE.mode = 'EXPLODE';
STATE.rotateVel = 0.05;

btn.innerHTML = "<span>✦</span> 上传成功 <span>✦</span>";
setTimeout(() => btn.innerHTML = "<span>✦</span> 上传照片 <span>✦</span>", 2000);

// 关键：清空 value，保证重复选择相同文件也会触发 change
input.value = '';
});
        }

        // --- 核心修复：更稳健的纹理加载 ---
        async function loadAndBuildGallery(urls) {
            clearGallery();

            const loader = new THREE.TextureLoader();
            const geometry = new THREE.PlaneGeometry(1, 1);
            const frameGeo = new THREE.BoxGeometry(1.05, 1.05, 0.02);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 }); 

            // 使用 loadAsync 确保纹理完全就绪
            // 这样可以避免 Texture(img) 带来的异步未完成问题
            const texturePromises = urls.map(url => {
                return loader.loadAsync(url)
                    .then(tex => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.minFilter = THREE.LinearFilter;
                        tex.magFilter = THREE.LinearFilter;
                        return tex;
                    })
                    .catch(err => null); // 忽略加载失败的
            });

            const textures = await Promise.all(texturePromises);
            const validTextures = textures.filter(t => t !== null);
            const total = validTextures.length;

            if (total === 0) return;

            validTextures.forEach((tex, i) => {
                const group = new THREE.Group();
                
                // 动态宽高比
                let w = 1, h = 1;
                const img = tex.image; 
                const baseSize = 1.5; 
                if (img.width > img.height) {
                    w = baseSize * (img.width / img.height);
                    h = baseSize;
                } else {
                    w = baseSize;
                    h = baseSize * (img.height / img.width);
                }

                // 创建照片 Mesh
                const planeGeo = new THREE.PlaneGeometry(w, h);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(planeGeo, mat);
                mesh.position.z = 0.05; 
                mesh.userData = { id: i }; 
                
                // 创建相框 Mesh
                const boxGeo = new THREE.BoxGeometry(w + 0.1, h + 0.1, 0.05);
                const frame = new THREE.Mesh(boxGeo, frameMat);
                
                group.add(frame);
                group.add(mesh);

                // 计算布局
                const ratio = i / total;
                const treeY = ratio * CONFIG.treeHeight * 0.9 - CONFIG.treeHeight * 0.45;
                const treeAngle = ratio * Math.PI * (8 + total/5); 
                const treeR = (1 - (treeY + CONFIG.treeHeight/2)/CONFIG.treeHeight) * CONFIG.treeRadius;
                
                const treePos = new THREE.Vector3(Math.cos(treeAngle)*treeR, treeY, Math.sin(treeAngle)*treeR);
                const treeRot = new THREE.Euler(0, -treeAngle, 0);

                const galleryAngle = (i / total) * Math.PI * 2; 
                const galleryR = 12 + Math.random() * 15; 
                const ex = Math.cos(galleryAngle) * galleryR;
                const ey = (Math.random() - 0.5) * 20; 
                const ez = Math.sin(galleryAngle) * galleryR;

                photoData.push({
                    obj: group,
                    treePos: treePos,
                    treeRot: treeRot,
                    explodePos: new THREE.Vector3(ex, ey, ez),
                    explodeScale: 1.5 + Math.random()
                });

                photoMeshes.push(mesh);
                mainGroup.add(group);
            });
        }

        

// --- 稳定方案：FileReader(DataURL) -> Image -> THREE.Texture（参考 1215.html） ---
async function loadAndBuildGalleryFromImages(images) {
    clearGallery();

    const frameMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

    const textures = images.map(img => {
        const tex = new THREE.Texture(img);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        return tex;
    });

    const total = textures.length;
    if (total === 0) return;

    textures.forEach((tex, i) => {
        const group = new THREE.Group();

        // 动态宽高比
        let w = 1, h = 1;
        const img = tex.image;
        const baseSize = 1.5;
        if (img && img.width && img.height) {
            if (img.width > img.height) {
                w = baseSize * (img.width / img.height);
                h = baseSize;
            } else {
                w = baseSize;
                h = baseSize * (img.height / img.width);
            }
        }

        // 创建照片 Mesh
        const planeGeo = new THREE.PlaneGeometry(w, h);
        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.z = 0.05;
        mesh.userData = { id: i };

        // 创建相框 Mesh
        const boxGeo = new THREE.BoxGeometry(w + 0.1, h + 0.1, 0.05);
        const frame = new THREE.Mesh(boxGeo, frameMat);

        group.add(frame);
        group.add(mesh);

        // 计算布局
        const ratio = i / total;
        const treeY = ratio * CONFIG.treeHeight * 0.9 - CONFIG.treeHeight * 0.45;
        const treeAngle = ratio * Math.PI * (8 + total / 5);
        const treeR = (1 - (treeY + CONFIG.treeHeight / 2) / CONFIG.treeHeight) * CONFIG.treeRadius;

        const treePos = new THREE.Vector3(Math.cos(treeAngle) * treeR, treeY, Math.sin(treeAngle) * treeR);
        const treeRot = new THREE.Euler(0, -treeAngle, 0);

        const galleryAngle = (i / total) * Math.PI * 2;
        const galleryR = 12 + Math.random() * 15;
        const ex = Math.cos(galleryAngle) * galleryR;
        const ey = (Math.random() - 0.5) * 20;
        const ez = Math.sin(galleryAngle) * galleryR;

        photoData.push({
            obj: group,
            treePos: treePos,
            treeRot: treeRot,
            explodePos: new THREE.Vector3(ex, ey, ez),
            explodeScale: 1.5 + Math.random()
        });

        photoMeshes.push(mesh);
        mainGroup.add(group);
    });
}

function clearGallery() {
            photoData.forEach(p => {
                mainGroup.remove(p.obj);
                // 深度清理
                if (p.obj.children[1]) {
                    const mesh = p.obj.children[1];
                    if(mesh.material.map) mesh.material.map.dispose();
                    mesh.material.dispose();
                    mesh.geometry.dispose();
                }
                if (p.obj.children[0]) {
                    const frame = p.obj.children[0];
                    frame.material.dispose();
                    frame.geometry.dispose();
                }
            });
            photoData = [];
            photoMeshes = [];
        }

        // --- 粒子系统 ---
        function createSupernovaParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const positions = [], treeDest = [], explodeDest = [], randoms = [], sizes = [];

            for (let i = 0; i < count; i++) {
                const iNorm = i / count;
                const angle = iNorm * Math.PI * 40; 
                const y = iNorm * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                const r = Math.pow((1 - (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight), 0.8) * CONFIG.treeRadius;
                const tx = Math.cos(angle) * r + (Math.random()-0.5);
                const ty = y + (Math.random()-0.5);
                const tz = Math.sin(angle) * r + (Math.random()-0.5);

                const ex = (Math.random() - 0.5) * 80;
                const ey = (Math.random() - 0.5) * 40;
                const ez = (Math.random() - 0.5) * 80;

                positions.push(tx, ty, tz);
                treeDest.push(tx, ty, tz);
                explodeDest.push(ex, ey, ez);
                randoms.push(Math.random());
                sizes.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('treeDest', new THREE.Float32BufferAttribute(treeDest, 3));
            geometry.setAttribute('explodeDest', new THREE.Float32BufferAttribute(explodeDest, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(CONFIG.particleColor) },
                    uMix: { value: 0 },
                    uFocus: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMix;
                    attribute vec3 treeDest;
                    attribute vec3 explodeDest;
                    attribute float aRandom;
                    attribute float aSize;
                    varying float vAlpha;
                    varying float vHotness; 
                    void main() {
                        vec3 pos = mix(treeDest, explodeDest, uMix);
                        if(uMix > 0.5) {
                            pos.x += sin(uTime + aRandom * 100.0) * 0.5;
                            pos.y += cos(uTime + aRandom * 50.0) * 0.5;
                        } else {
                             pos.x += sin(uTime * 1.5 + pos.y * 0.2) * 0.2;
                        }
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (2.0 + aSize * 4.0) * (30.0 / -mvPosition.z);
                        float blink = sin(uTime * 4.0 + aRandom * 60.0);
                        vAlpha = 0.5 + 0.5 * blink;
                        vHotness = step(0.8, aRandom); 
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform float uFocus;
                    varying float vAlpha;
                    varying float vHotness;
                    void main() {
                        vec2 xy = gl_PointCoord.xy - vec2(0.5);
                        if (length(xy) > 0.5) discard;
                        float glow = 1.0 - (length(xy) * 2.0);
                        glow = pow(glow, 2.5);
                        vec3 col = uColor;
                        if (vHotness > 0.5) col = mix(uColor, vec3(1.0), glow * 0.8);
                        float b = vAlpha * glow * 1.5; 
                        if(uFocus > 0.5) b *= 0.05;
                        gl_FragColor = vec4(col, b);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, particleMaterial);
            mainGroup.add(particles); 
        }

        // --- MediaPipe ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            MP_HANDS = hands;
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    try {
                        await hands.send({ image: videoElement });
                        MP_LAST_TS = performance.now();
                    } catch (err) {
                        console.error('[MediaPipe] hands.send error', err);
                    }
                },
                width: 320, height: 240
            });
            MP_CAMERA = cameraUtils;

            // Start camera (some browsers may pause after file-picker; we also resume on focus)
            try {
                cameraUtils.start();
            } catch (err) {
                console.error('[MediaPipe] camera start error', err);
            }

            const tryPlay = () => videoElement.play().catch(() => {});
            window.addEventListener('focus', tryPlay);
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) tryPlay();
            });

            // Watchdog: if callbacks stall (e.g., after file picker), re-init.
            setInterval(() => {
                const now = performance.now();
                if (MP_LAST_TS && now - MP_LAST_TS > 1500) {
                    console.warn('[MediaPipe] stalled, reinitializing...');
                    try { document.getElementById('cursor-hint').style.display = 'none'; } catch {}
                    MP_LAST_TS = now;
                    // Recreate pipeline
                    try {
                        initMediaPipe();
                    } catch (e) {
                        console.error('[MediaPipe] reinit failed', e);
                    }
                }
            }, 1000);
        }

        function onHandsResults(results) {
            MP_LAST_TS = performance.now();
            const canvas = document.getElementById('skeleton-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 320; canvas.height = 240;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cursorHint = document.getElementById('cursor-hint');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.inputSource = 'HAND';
                STATE.isHandPresent = true;
                const landmarks = results.multiHandLandmarks[0];
                drawSkeleton(ctx, landmarks, canvas.width, canvas.height);
                processHandLogic(landmarks);
                cursorHint.style.display = 'block'; 
            } else {
                STATE.isHandPresent = false;
                STATE.hoverIndex = -1; 
                cursorHint.style.display = 'none';
            }
        }

        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 3; ctx.strokeStyle = '#00ff88'; ctx.fillStyle = '#ff0044';
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            ctx.beginPath();
            for (let i = 0; i < connections.length; i++) {
                const start = landmarks[connections[i][0]];
                const end = landmarks[connections[i][1]];
                ctx.moveTo(start.x * w, start.y * h); 
                ctx.lineTo(end.x * w, end.y * h);
            }
            ctx.stroke();
            for(let i=0; i<landmarks.length; i++) { ctx.beginPath(); ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 3, 0, 2 * Math.PI); ctx.fill(); }
        }

        function processHandLogic(landmarks) {
            const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; 
            const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            STATE.handPos.x = palmX * 0.8 + STATE.handPos.x * 0.2; 
            STATE.handPos.y = palmY * 0.8 + STATE.handPos.y * 0.2;
            
            const cursorHint = document.getElementById('cursor-hint');
            cursorHint.style.left = (STATE.handPos.x * 100) + '%';
            cursorHint.style.top = (STATE.handPos.y * 100) + '%';

            const ndcX = STATE.handPos.x * 2 - 1;
            const ndcY = -(STATE.handPos.y * 2 - 1);
            STATE.pinchPos.set(ndcX, ndcY); 
            updateCursorLight(ndcX, ndcY);

            let folded = 0;
            [8,12,16,20].forEach(i => { 
                const d = Math.sqrt(Math.pow(landmarks[i].x-landmarks[0].x,2) + Math.pow(landmarks[i].y-landmarks[0].y,2));
                if(d < 0.25) folded++;
            });
            const isFist = folded >= 4;
            const dPinch = Math.sqrt(Math.pow(landmarks[4].x-landmarks[8].x,2) + Math.pow(landmarks[4].y-landmarks[8].y,2));
            const isPinch = dPinch < 0.08; 
            const isOpen = !isFist && !isPinch;

            if (STATE.mode === 'EXPLODE') {
                raycaster.setFromCamera(STATE.pinchPos, camera);
                const intersects = raycaster.intersectObjects(photoMeshes);
                if (intersects.length > 0) {
                    STATE.hoverIndex = intersects[0].object.userData.id;
                    cursorHint.style.borderColor = '#00ff00';
                    cursorHint.style.transform = 'translate(-50%, -50%) scale(1.5)';
                } else {
                    STATE.hoverIndex = -1;
                    cursorHint.style.borderColor = 'rgba(255, 255, 255, 0.8)';
                    cursorHint.style.transform = 'translate(-50%, -50%) scale(1)';
                }
            } else { STATE.hoverIndex = -1; }

            if (isFist) {
                STATE.mode = 'TREE'; STATE.rotateVel = 0;
            } else if (isPinch && STATE.mode === 'EXPLODE') {
                if (STATE.hoverIndex !== -1) {
                    STATE.focusIndex = STATE.hoverIndex;
                    STATE.mode = 'FOCUS';
                }
            } else if (isOpen) {
                if (STATE.mode === 'TREE') { STATE.mode = 'EXPLODE'; STATE.lastHandPos.x = STATE.handPos.x; } 
                else if (STATE.mode === 'FOCUS' && !isPinch) { STATE.mode = 'EXPLODE'; }
                
                if (STATE.mode === 'EXPLODE') {
                    const deltaX = STATE.handPos.x - STATE.lastHandPos.x;
                    STATE.rotateVel += deltaX * 0.2; 
                }
            }
            STATE.lastHandPos.x = STATE.handPos.x;
            STATE.lastHandPos.y = STATE.handPos.y;
        }

        // --- 输入处理 ---
        function initInput() {
            const uploadContainer = document.getElementById('upload-container');
            uploadContainer.addEventListener('mousedown', (e) => e.stopPropagation());
            uploadContainer.addEventListener('touchstart', (e) => e.stopPropagation());

            document.addEventListener('mousedown', onPointerDown);
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchstart', onPointerDown, {passive: false});
            document.addEventListener('touchmove', onPointerMove, {passive: false});
            document.addEventListener('touchend', onPointerUp);
        }

        let touchStartX = 0;
        let touchStartTime = 0;

        function onPointerDown(e) {
            STATE.isDragging = true;
            if(STATE.inputSource !== 'HAND') STATE.inputSource = 'MOUSE';
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            STATE.lastMouseX = x;
            touchStartX = x;
            touchStartTime = Date.now();
        }

        function onPointerMove(e) {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            
            if (STATE.inputSource !== 'HAND') {
                STATE.mousePos.x = (x / window.innerWidth) * 2 - 1;
                STATE.mousePos.y = -(y / window.innerHeight) * 2 + 1;
                
                if (STATE.mode === 'EXPLODE') {
                    raycaster.setFromCamera(STATE.mousePos, camera);
                    const intersects = raycaster.intersectObjects(photoMeshes);
                    if(intersects.length > 0) STATE.hoverIndex = intersects[0].object.userData.id;
                    else STATE.hoverIndex = -1;
                }
                updateCursorLight(STATE.mousePos.x, STATE.mousePos.y);
            }

            if (STATE.isDragging && STATE.mode === 'EXPLODE') {
                e.preventDefault(); 
                const deltaX = x - STATE.lastMouseX;
                STATE.rotateVel = deltaX * 0.005; 
                STATE.lastMouseX = x;
            }
        }

        function onPointerUp(e) {
            STATE.isDragging = false;
            const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const dist = Math.abs(x - touchStartX);
            if (dist < 10 && (Date.now() - touchStartTime) < 300 && e.target.tagName !== 'BUTTON') {
                if (STATE.hoverIndex !== -1 && STATE.mode === 'EXPLODE') {
                    STATE.focusIndex = STATE.hoverIndex;
                    STATE.mode = 'FOCUS';
                } else {
                    if (STATE.mode === 'TREE') STATE.mode = 'EXPLODE';
                    else if (STATE.mode === 'EXPLODE') {/* do nothing */}
                    else if (STATE.mode === 'FOCUS') STATE.mode = 'EXPLODE';
                }
            }
        }

        function updateCursorLight(ndcX, ndcY) {
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            cursorLight.position.lerp(camera.position.clone().add(dir.multiplyScalar(20)), 0.1);
            cursorLight.intensity = STATE.mode === 'TREE' ? 10 : 5;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            let targetMix = STATE.mode === 'TREE' ? 0 : 1;
            STATE.mix += (targetMix - STATE.mix) * 2.0 * delta;
            
            if (STATE.mode === 'TREE') {
                STATE.rotationY += 0.2 * delta;
                mainGroup.rotation.y = STATE.rotationY;
                STATE.rotateVel = 0;
            } else {
                if (!STATE.isDragging && !STATE.isHandPresent) STATE.rotateVel *= 0.95; 
                if (STATE.isHandPresent) STATE.rotateVel *= 0.90;
                STATE.rotationY += STATE.rotateVel;
                mainGroup.rotation.y = STATE.rotationY;
            }

            let targetFocus = STATE.mode === 'FOCUS' ? 1 : 0;
            if(particles) {
                particleMaterial.uniforms.uTime.value = time;
                particleMaterial.uniforms.uMix.value = STATE.mix;
                particleMaterial.uniforms.uFocus.value = THREE.MathUtils.lerp(particleMaterial.uniforms.uFocus.value, targetFocus, 0.1);
            }

            photoData.forEach((p, i) => {
                let targetPos, targetScale = 1;
                const isFocused = (i === STATE.focusIndex);
                const isHovered = (i === STATE.hoverIndex);

                if (STATE.mix > 0.5) { // 炸裂
                    if (isFocused) {
                        const invWorldRot = mainGroup.quaternion.clone().invert();
                        const camFrontLocal = new THREE.Vector3(0, 0, 32).applyQuaternion(invWorldRot);
                        targetPos = camFrontLocal;
                        targetScale = 3.5;
                    } else {
                        targetPos = p.explodePos.clone();
                        targetPos.y += Math.sin(time + i) * 0.5; 
                        targetScale = p.explodeScale;
                        if (isHovered && STATE.mode === 'EXPLODE') targetScale *= 1.3;
                        if (STATE.mode === 'FOCUS') targetScale = 0.0; 
                    }
                } else { // 树
                    targetPos = p.treePos.clone();
                    targetScale = 1.0;
                }

                p.obj.position.lerp(targetPos, 0.1);
                p.obj.scale.setScalar(THREE.MathUtils.lerp(p.obj.scale.x, targetScale, 0.1));

                if (STATE.mix > 0.5) {
                    const parentQ = mainGroup.quaternion.clone();
                    const cameraQ = camera.quaternion.clone(); 
                    const targetQ = parentQ.invert().multiply(cameraQ);
                    
                    if (isFocused) {
                        const tx = (STATE.inputSource==='HAND'?STATE.pinchPos.y:STATE.mousePos.y)*0.2;
                        const ty = (STATE.inputSource==='HAND'?STATE.pinchPos.x:STATE.mousePos.x)*0.2;
                        targetQ.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(tx,ty,0)));
                    } else if (isHovered) {
                        const tx = (STATE.inputSource==='HAND'?STATE.pinchPos.y:STATE.mousePos.y)*0.1;
                        const ty = (STATE.inputSource==='HAND'?STATE.pinchPos.x:STATE.mousePos.x)*0.1;
                        targetQ.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(tx,ty,0)));
                    }
                    p.obj.quaternion.slerp(targetQ, 0.1);
                } else {
                    p.obj.quaternion.slerp(new THREE.Quaternion().setFromEuler(p.treeRot), 0.1);
                }
            });
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            adjustCameraPosition();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
