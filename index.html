<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>For You | Gesture Galaxy X</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Cinzel', serif;
            cursor: grab;
        }
        canvas { display: block; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10;
        }

        #title {
            color: #fff; font-size: 4rem; font-weight: 700; letter-spacing: 8px;
            text-shadow: 0 0 30px rgba(255, 200, 50, 0.8);
            opacity: 0; transition: opacity 2s ease; mix-blend-mode: screen; text-align: center;
        }
        
        #subtitle {
            margin-top: 15px; color: rgba(255, 255, 255, 0.8); font-size: 1.2rem; letter-spacing: 4px;
            opacity: 0; transition: opacity 2s ease 1s; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* å‚è€ƒ 1215.html çš„æ‘„åƒå¤´æ ·å¼ */
        #video-container {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; z-index: 20;
            border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            transition: opacity 0.3s;
            opacity: 0.8;
        }
        #input-video { 
            width: 100%; height: 100%; object-fit: cover; opacity: 0.4; 
            position: absolute; top: 0; left: 0;
        }
        #skeleton-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; font-size: 14px; letter-spacing: 2px; animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { opacity: 0.3; } to { opacity: 1; text-shadow: 0 0 20px #ffd700; } }

        /* æ“ä½œæç¤º */
        #instructions {
            position: absolute; bottom: 20px; left: 20px; 
            color: rgba(255,255,255,0.6); font-size: 12px; line-height: 1.8;
            pointer-events: none; opacity: 0; transition: opacity 2s ease 2s;
            text-align: left;
        }
        .highlight { color: #ffd700; font-weight: bold; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="video-container">
        <video id="input-video" playsinline muted></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>

    <div id="loading">INITIALIZING AI VISION...</div>
    
    <div id="ui-layer">
        <div id="title">Merry Christmas</div>
        <div id="subtitle">The Galaxy of You</div>
    </div>

    <div id="instructions">
        â€¢ <span class="highlight">æ¡æ‹³</span> : èšåˆåœ£è¯æ ‘<br/>
        â€¢ <span class="highlight">äº”æŒ‡å¼ å¼€</span> : ç‚¸è£‚æ˜Ÿç³»<br/>
        â€¢ <span class="highlight">å·¦å³æŒ¥æ‰‹</span> : æ—‹è½¬æ˜Ÿç³»<br/>
        â€¢ <span class="highlight">æåˆæ‰‹æŒ‡</span> : æŠ“å–ç…§ç‰‡
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½®åŒº (V3.6 è§†è§‰é…ç½®) ---
        const CONFIG = {
            particleCount: 6000,
            particleColor: 0xffaa33, 
            treeHeight: 30, 
            treeRadius: 12,
            photos: [], 
        };

        // ğŸŸ¢ å¡«å…¥ç…§ç‰‡é“¾æ¥
        const YOUR_PHOTOS = [
            // 'https://...',
        ];

        if (YOUR_PHOTOS.length > 0) {
            CONFIG.photos = YOUR_PHOTOS;
        } else {
            for (let i = 0; i < 30; i++) {
                CONFIG.photos.push(`https://picsum.photos/id/${i + 15}/600/600`);
            }
        }

        // --- çŠ¶æ€ç®¡ç† (èåˆ 1215.html é€»è¾‘) ---
        const STATE = {
            mode: 'TREE',
            mix: 0,
            focusIndex: -1,
            pinchPos: new THREE.Vector2(),
            inputSource: 'NONE', 
            mousePos: new THREE.Vector2(),
            
            // æ—‹è½¬ä¸æ‰‹åŠ¿çŠ¶æ€
            rotationY: 0,
            rotateVel: 0,
            isDragging: false,
            lastMouseX: 0,
            
            // æ‰‹åŠ¿ä¸“ç”¨å˜é‡
            handPos: { x: 0, y: 0 },
            lastHandPos: { x: 0, y: 0 },
            isHandPresent: false
        };

        let scene, camera, renderer, composer;
        let mainGroup; 
        let particles, particleMaterial;
        let photos = [];
        let clock = new THREE.Clock();
        const cursorLight = new THREE.PointLight(0xffaa00, 0, 15);

        init();
        initMediaPipe(); 
        initInput(); 
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 40);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(cursorLight);

            // Bloom
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 3.5; bloomPass.radius = 0.6;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createSupernovaParticles();
            createClearGallery();

            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('title').style.opacity = 1;
                document.getElementById('subtitle').style.opacity = 1;
                document.getElementById('instructions').style.opacity = 1;
            }, 1000);

            window.addEventListener('resize', onWindowResize);
        }

        // --- ç²’å­ä¸ç…§ç‰‡ (V3.6 è§†è§‰æ ¸å¿ƒ) ---
        function createSupernovaParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            const positions = [], treeDest = [], explodeDest = [], randoms = [], sizes = [];

            for (let i = 0; i < count; i++) {
                const iNorm = i / count;
                const angle = iNorm * Math.PI * 40; 
                const y = iNorm * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                const r = Math.pow((1 - (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight), 0.8) * CONFIG.treeRadius;
                const tx = Math.cos(angle) * r + (Math.random()-0.5);
                const ty = y + (Math.random()-0.5);
                const tz = Math.sin(angle) * r + (Math.random()-0.5);

                const ex = (Math.random() - 0.5) * 80;
                const ey = (Math.random() - 0.5) * 40;
                const ez = (Math.random() - 0.5) * 80;

                positions.push(tx, ty, tz);
                treeDest.push(tx, ty, tz);
                explodeDest.push(ex, ey, ez);
                randoms.push(Math.random());
                sizes.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('treeDest', new THREE.Float32BufferAttribute(treeDest, 3));
            geometry.setAttribute('explodeDest', new THREE.Float32BufferAttribute(explodeDest, 3));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(CONFIG.particleColor) },
                    uMix: { value: 0 },
                    uFocus: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uMix;
                    attribute vec3 treeDest;
                    attribute vec3 explodeDest;
                    attribute float aRandom;
                    attribute float aSize;
                    varying float vAlpha;
                    varying float vHotness; 
                    void main() {
                        vec3 pos = mix(treeDest, explodeDest, uMix);
                        if(uMix > 0.5) {
                            pos.x += sin(uTime + aRandom * 100.0) * 0.5;
                            pos.y += cos(uTime + aRandom * 50.0) * 0.5;
                        } else {
                             pos.x += sin(uTime * 1.5 + pos.y * 0.2) * 0.2;
                        }
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (2.0 + aSize * 4.0) * (30.0 / -mvPosition.z);
                        float blink = sin(uTime * 4.0 + aRandom * 60.0);
                        vAlpha = 0.5 + 0.5 * blink;
                        vHotness = step(0.8, aRandom); 
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    uniform float uFocus;
                    varying float vAlpha;
                    varying float vHotness;
                    void main() {
                        vec2 xy = gl_PointCoord.xy - vec2(0.5);
                        if (length(xy) > 0.5) discard;
                        float glow = 1.0 - (length(xy) * 2.0);
                        glow = pow(glow, 2.5);
                        vec3 col = uColor;
                        if (vHotness > 0.5) col = mix(uColor, vec3(1.0), glow * 0.8);
                        float b = vAlpha * glow * 1.5; 
                        if(uFocus > 0.5) b *= 0.05;
                        gl_FragColor = vec4(col, b);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, particleMaterial);
            mainGroup.add(particles); 
        }

        function createClearGallery() {
            const loader = new THREE.TextureLoader();
            const geometry = new THREE.PlaneGeometry(1, 1);
            const frameGeo = new THREE.BoxGeometry(1.05, 1.05, 0.02);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 }); 

            CONFIG.photos.forEach((url, i) => {
                const group = new THREE.Group();
                loader.load(url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: tex }));
                    mesh.position.z = 0.02;
                    group.add(mesh);
                });
                group.add(new THREE.Mesh(frameGeo, frameMat));

                const ratio = i / CONFIG.photos.length;
                const treeY = ratio * CONFIG.treeHeight * 0.9 - CONFIG.treeHeight * 0.45;
                const treeAngle = ratio * Math.PI * 12; 
                const treeR = (1 - (treeY + CONFIG.treeHeight/2)/CONFIG.treeHeight) * CONFIG.treeRadius;
                
                const galleryAngle = (i / CONFIG.photos.length) * Math.PI * 2; 
                const galleryR = 15 + Math.random() * 10; 
                const ex = Math.cos(galleryAngle) * galleryR;
                const ey = (Math.random() - 0.5) * 20; 
                const ez = Math.sin(galleryAngle) * galleryR;

                photos.push({
                    obj: group,
                    treePos: new THREE.Vector3(Math.cos(treeAngle)*treeR, treeY, Math.sin(treeAngle)*treeR),
                    treeRot: new THREE.Euler(0, -treeAngle, 0), 
                    explodePos: new THREE.Vector3(ex, ey, ez),
                    explodeScale: 2.5 + Math.random()
                });
                mainGroup.add(group); 
            });
        }

        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (æ ¸å¿ƒç§»æ¤åŒº) ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            const canvas = document.getElementById('skeleton-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 320; canvas.height = 240;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.inputSource = 'HAND';
                STATE.isHandPresent = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. ç»˜åˆ¶éª¨æ¶ (ç§»æ¤è‡ª 1215.html)
                drawSkeleton(ctx, landmarks, canvas.width, canvas.height);
                
                // 2. æ‰‹åŠ¿é€»è¾‘å¤„ç†
                processHandLogic(landmarks);
            } else {
                STATE.isHandPresent = false;
                // å¦‚æœæ‰‹æ¶ˆå¤±äº†ï¼Œæ˜¯å¦å›åˆ°æ ‘ï¼Ÿå‚è€ƒä»£ç é€»è¾‘æ˜¯ï¼šæ‰‹æ¶ˆå¤±ä¸åšçŠ¶æ€å¼ºåˆ¶åˆ‡æ¢ï¼Œä¿æŒå½“å‰çŠ¶æ€
            }
        }

        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.lineWidth = 3; ctx.strokeStyle = '#00ff88'; ctx.fillStyle = '#ff0044';
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
            
            ctx.beginPath();
            for (let i = 0; i < connections.length; i++) {
                const start = landmarks[connections[i][0]];
                const end = landmarks[connections[i][1]];
                ctx.moveTo(start.x * w, start.y * h); 
                ctx.lineTo(end.x * w, end.y * h);
            }
            ctx.stroke();

            // ç»˜åˆ¶å…³é”®ç‚¹
            for(let i=0; i<landmarks.length; i++) { 
                ctx.beginPath(); 
                ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 3, 0, 2 * Math.PI); 
                ctx.fill(); 
            }
        }

        function processHandLogic(landmarks) {
            // æ›´æ–°æ‰‹æŒä¸­å¿ƒä½ç½®
            const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2; // é•œåƒç¿»è½¬X
            const palmY = (landmarks[0].y + landmarks[9].y) / 2;
            
            // æ›´æ–°å…‰æ ‡ä½ç½®
            STATE.handPos.x = palmX * 0.8 + STATE.handPos.x * 0.2; // å¹³æ»‘
            STATE.handPos.y = palmY * 0.8 + STATE.handPos.y * 0.2;
            updateCursorLight(STATE.handPos.x * 2 - 1, -(STATE.handPos.y * 2 - 1));

            // --- åˆ¤å®šé€»è¾‘ (ç§»æ¤è‡ª 1215.html) ---
            
            // 1. æ¡æ‹³åˆ¤å®š (è®¡ç®—æŒ‡å°–åˆ°æŒå¿ƒçš„è·ç¦»)
            let folded = 0;
            [8,12,16,20].forEach(i => { 
                const d = Math.sqrt(Math.pow(landmarks[i].x-landmarks[0].x,2) + Math.pow(landmarks[i].y-landmarks[0].y,2));
                if(d < 0.25) folded++; // é˜ˆå€¼å‚è€ƒ 0.35, è¿™é‡Œç¨å¾®ä¸¥ä¸€ç‚¹
            });
            const isFist = folded >= 4;

            // 2. æåˆåˆ¤å®š
            const dPinch = Math.sqrt(Math.pow(landmarks[4].x-landmarks[8].x,2) + Math.pow(landmarks[4].y-landmarks[8].y,2));
            const isPinch = dPinch < 0.1; // 1215.html é˜ˆå€¼
            
            // 3. å¼ å¼€åˆ¤å®š
            const isOpen = !isFist && !isPinch;

            // --- çŠ¶æ€æœºåˆ‡æ¢ ---
            if (isFist) {
                // æ¡æ‹³ -> æ ‘
                STATE.mode = 'TREE';
                STATE.rotateVel = 0; // åœæ­¢æ‰‹åŠ¨æ—‹è½¬
            } 
            else if (isPinch && STATE.mode === 'EXPLODE') {
                // ç‚¸è£‚ä¸‹æåˆ -> èšç„¦
                STATE.mode = 'FOCUS';
                // è®°å½•æåˆä¸­å¿ƒç‚¹ (å½’ä¸€åŒ–åˆ° NDC)
                const cx = (landmarks[4].x + landmarks[8].x) / 2;
                const cy = (landmarks[4].y + landmarks[8].y) / 2;
                STATE.pinchPos.set((1-cx)*2-1, -(cy*2-1));
            }
            else if (isOpen) {
                // å¼ å¼€
                if (STATE.mode === 'TREE') {
                    // æ ‘ -> ç‚¸è£‚
                    STATE.mode = 'EXPLODE';
                    // é‡ç½®ä¸Šä¸€å¸§ä½ç½®ï¼Œé˜²æ­¢ç‚¸å¼€ç¬é—´ä¹±è½¬
                    STATE.lastHandPos.x = STATE.handPos.x;
                } else if (STATE.mode === 'FOCUS' && !isPinch) {
                    // æ¾å¼€æåˆ -> å›åˆ°ç‚¸è£‚
                    STATE.mode = 'EXPLODE';
                }
                
                // ç‚¸è£‚çŠ¶æ€ä¸‹çš„æ—‹è½¬æ§åˆ¶ (å‚è€ƒ 1215.html çš„ Delta é€»è¾‘)
                if (STATE.mode === 'EXPLODE') {
                    const deltaX = STATE.handPos.x - STATE.lastHandPos.x;
                    // æ”¾å¤§ç³»æ•°ï¼Œæ‰‹åˆ’åŠ¨ä¸€ç‚¹ç‚¹ï¼Œæ˜Ÿç³»è½¬åŠ¨å¤šä¸€ç‚¹
                    STATE.rotateVel += deltaX * 0.2; 
                }
            }

            // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
            STATE.lastHandPos.x = STATE.handPos.x;
            STATE.lastHandPos.y = STATE.handPos.y;
        }

        // --- é¼ æ ‡/è§¦æ‘¸è¾“å…¥ (ä¿ç•™ä½œä¸ºä¿åº•) ---
        function initInput() {
            document.addEventListener('mousedown', onPointerDown);
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('mouseup', onPointerUp);
            document.addEventListener('touchstart', onPointerDown, {passive: false});
            document.addEventListener('touchmove', onPointerMove, {passive: false});
            document.addEventListener('touchend', onPointerUp);
        }

        let touchStartX = 0;
        let touchStartTime = 0;

        function onPointerDown(e) {
            STATE.isDragging = true;
            if(STATE.inputSource !== 'HAND') STATE.inputSource = 'MOUSE';
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            STATE.lastMouseX = x;
            touchStartX = x;
            touchStartTime = Date.now();
        }

        function onPointerMove(e) {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            
            // å¦‚æœæ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œæ‰ç”¨é¼ æ ‡æ›´æ–°å…‰æ ‡
            if (STATE.inputSource !== 'HAND') {
                STATE.mousePos.x = (x / window.innerWidth) * 2 - 1;
                STATE.mousePos.y = -(y / window.innerHeight) * 2 + 1;
                updateCursorLight(STATE.mousePos.x, STATE.mousePos.y);
            }

            if (STATE.isDragging && STATE.mode === 'EXPLODE') {
                e.preventDefault(); 
                const deltaX = x - STATE.lastMouseX;
                STATE.rotateVel = deltaX * 0.005; 
                STATE.lastMouseX = x;
            }
        }

        function onPointerUp(e) {
            STATE.isDragging = false;
            if(STATE.inputSource === 'HAND') return; // æ‰‹åŠ¿ä¼˜å…ˆ

            const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const dist = Math.abs(x - touchStartX);
            if (dist < 10 && (Date.now() - touchStartTime) < 300) {
                if (STATE.mode === 'TREE') STATE.mode = 'EXPLODE';
                else if (STATE.mode === 'EXPLODE') STATE.mode = 'FOCUS';
                else STATE.mode = 'TREE';
            }
        }

        function updateCursorLight(ndcX, ndcY) {
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            cursorLight.position.lerp(camera.position.clone().add(dir.multiplyScalar(20)), 0.1);
            cursorLight.intensity = STATE.mode === 'TREE' ? 10 : 5;
        }

        // --- æ ¸å¿ƒåŠ¨ç”» ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            let targetMix = STATE.mode === 'TREE' ? 0 : 1;
            STATE.mix += (targetMix - STATE.mix) * 2.0 * delta;
            
            // æ—‹è½¬é€»è¾‘
            if (STATE.mode === 'TREE') {
                STATE.rotationY += 0.2 * delta;
                mainGroup.rotation.y = STATE.rotationY;
                STATE.rotateVel = 0;
            } else {
                if (!STATE.isDragging && !STATE.isHandPresent) {
                    STATE.rotateVel *= 0.95; // é˜»å°¼
                }
                // åœ¨æ‰‹åŠ¿æ§åˆ¶ä¸‹ï¼Œé˜»å°¼ç¨å¾®å°ä¸€ç‚¹ï¼Œæ»‘å¾—æ›´é¡º
                if (STATE.isHandPresent) STATE.rotateVel *= 0.90;

                STATE.rotationY += STATE.rotateVel;
                mainGroup.rotation.y = STATE.rotationY;
            }

            let targetFocus = STATE.mode === 'FOCUS' ? 1 : 0;
            if(particles) {
                particleMaterial.uniforms.uTime.value = time;
                particleMaterial.uniforms.uMix.value = STATE.mix;
                particleMaterial.uniforms.uFocus.value = THREE.MathUtils.lerp(particleMaterial.uniforms.uFocus.value, targetFocus, 0.1);
            }

            // èšç„¦è®¡ç®—
            if(STATE.mode === 'FOCUS' && STATE.focusIndex === -1) {
                let minD = Infinity;
                photos.forEach((p, i) => {
                    const worldPos = new THREE.Vector3();
                    p.obj.getWorldPosition(worldPos);
                    const ndc = worldPos.clone().project(camera);
                    const d = ndc.distanceTo(new THREE.Vector3(STATE.pinchPos.x, STATE.pinchPos.y, ndc.z));
                    if(d < minD && ndc.z < 1) { minD = d; STATE.focusIndex = i; }
                });
            }
            if(STATE.mode !== 'FOCUS') STATE.focusIndex = -1;

            photos.forEach((p, i) => {
                let targetPos, targetScale = 1;
                const isSelected = (i === STATE.focusIndex);

                if (STATE.mix > 0.5) { // ç‚¸è£‚
                    if (isSelected) {
                        const invWorldRot = mainGroup.quaternion.clone().invert();
                        const camFrontLocal = new THREE.Vector3(0, 0, 32).applyQuaternion(invWorldRot);
                        targetPos = camFrontLocal;
                        targetScale = 3.5;
                    } else {
                        targetPos = p.explodePos.clone();
                        targetPos.y += Math.sin(time + i) * 0.5; 
                        targetScale = p.explodeScale;
                        if (STATE.mode === 'FOCUS') targetScale = 0.0; 
                    }
                } else { // æ ‘
                    targetPos = p.treePos.clone();
                    targetScale = 1.0;
                }

                p.obj.position.lerp(targetPos, 0.1);
                p.obj.scale.setScalar(THREE.MathUtils.lerp(p.obj.scale.x, targetScale, 0.1));

                // Billboard
                if (STATE.mix > 0.5) {
                    const parentQ = mainGroup.quaternion.clone();
                    const cameraQ = camera.quaternion.clone(); 
                    const targetQ = parentQ.invert().multiply(cameraQ);
                    if (isSelected) {
                         const tx = (STATE.inputSource==='HAND'?STATE.pinchPos.y:STATE.mousePos.y)*0.2;
                         const ty = (STATE.inputSource==='HAND'?STATE.pinchPos.x:STATE.mousePos.x)*0.2;
                         targetQ.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(tx,ty,0)));
                    }
                    p.obj.quaternion.slerp(targetQ, 0.1);
                } else {
                    p.obj.quaternion.slerp(new THREE.Quaternion().setFromEuler(p.treeRot), 0.1);
                }
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
